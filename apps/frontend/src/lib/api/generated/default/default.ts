/**
 * Generated by orval v8.0.1 üç∫
 * Do not edit manually.
 * PTK-Connext API
 * Digital system for learning and management for students, teachers, and parents of Pathumthep Wittayakarn School
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  DeleteNotificationsId200,
  DeleteNotificationsId401,
  DeleteNotificationsId403,
  DeleteNotificationsId500,
  GetConductMe200,
  GetConductMeParams,
  GetConductStudentStudentId200,
  GetConductStudentStudentIdParams,
  GetConductTerms200,
  GetNotifications200,
  GetNotifications401,
  GetNotifications500,
  GetNotificationsDashboard200,
  GetNotificationsDashboard500,
  GetStudents200,
  GetStudentsMe200,
  GetStudentsParams,
  PostAuthLogin200,
  PostAuthLogin401,
  PostAuthLogin500,
  PostAuthLoginBody,
  PostConductLogs200,
  PostConductLogsBody,
  PostNotifications201,
  PostNotifications401,
  PostNotifications403,
  PostNotifications500,
  PostNotificationsBody,
  PutNotificationsId200,
  PutNotificationsId401,
  PutNotificationsId403,
  PutNotificationsId404,
  PutNotificationsId500,
  PutNotificationsIdBody
} from '.././model';

import { customInstance } from '../../axios-instance';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Login endpoint that handles both student and teacher authentication. If studentId contains an email, treats it as teacher login.
 * @summary Hybrid Login (Student or Teacher)
 */
export type postAuthLoginResponse200 = {
  data: PostAuthLogin200
  status: 200
}

export type postAuthLoginResponse401 = {
  data: PostAuthLogin401
  status: 401
}

export type postAuthLoginResponse500 = {
  data: PostAuthLogin500
  status: 500
}
    
export type postAuthLoginResponseSuccess = (postAuthLoginResponse200) & {
  headers: Headers;
};
export type postAuthLoginResponseError = (postAuthLoginResponse401 | postAuthLoginResponse500) & {
  headers: Headers;
};

export type postAuthLoginResponse = (postAuthLoginResponseSuccess | postAuthLoginResponseError)

export const getPostAuthLoginUrl = () => {


  

  return `/auth/login`
}

export const postAuthLogin = async (postAuthLoginBody: PostAuthLoginBody, options?: RequestInit): Promise<postAuthLoginResponse> => {
  
  return customInstance<postAuthLoginResponse>(getPostAuthLoginUrl(),
  {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      postAuthLoginBody,)
  }
);}




export const getPostAuthLoginMutationOptions = <TError = PostAuthLogin401 | PostAuthLogin500,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAuthLogin>>, TError,{data: PostAuthLoginBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postAuthLogin>>, TError,{data: PostAuthLoginBody}, TContext> => {

const mutationKey = ['postAuthLogin'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAuthLogin>>, {data: PostAuthLoginBody}> = (props) => {
          const {data} = props ?? {};

          return  postAuthLogin(data,requestOptions)
        }






  return  { mutationFn, ...mutationOptions }}

    export type PostAuthLoginMutationResult = NonNullable<Awaited<ReturnType<typeof postAuthLogin>>>
    export type PostAuthLoginMutationBody = PostAuthLoginBody
    export type PostAuthLoginMutationError = PostAuthLogin401 | PostAuthLogin500

    /**
 * @summary Hybrid Login (Student or Teacher)
 */
export const usePostAuthLogin = <TError = PostAuthLogin401 | PostAuthLogin500,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAuthLogin>>, TError,{data: PostAuthLoginBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postAuthLogin>>,
        TError,
        {data: PostAuthLoginBody},
        TContext
      > => {
      return useMutation(getPostAuthLoginMutationOptions(options), queryClient);
    }
    /**
 * Retrieve a paginated list of students. Requires Authentication.
 * @summary List Students
 */
export type getStudentsResponse200 = {
  data: GetStudents200
  status: 200
}

export type getStudentsResponseSuccess = (getStudentsResponse200) & {
  headers: Headers;
};
;

export type getStudentsResponse = (getStudentsResponseSuccess)

export const getGetStudentsUrl = (params?: GetStudentsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {

    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/students?${stringifiedParams}` : `/students`
}

export const getStudents = async (params?: GetStudentsParams, options?: RequestInit): Promise<getStudentsResponse> => {

  return customInstance<getStudentsResponse>(getGetStudentsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetStudentsQueryKey = (params?: GetStudentsParams,) => {
    return [
    `/students`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetStudentsQueryOptions = <TData = Awaited<ReturnType<typeof getStudents>>, TError = unknown>(params?: GetStudentsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudents>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStudentsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStudents>>> = ({ signal }) => getStudents(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getStudents>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetStudentsQueryResult = NonNullable<Awaited<ReturnType<typeof getStudents>>>
export type GetStudentsQueryError = unknown


export function useGetStudents<TData = Awaited<ReturnType<typeof getStudents>>, TError = unknown>(
 params: undefined |  GetStudentsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudents>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStudents>>,
          TError,
          Awaited<ReturnType<typeof getStudents>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStudents<TData = Awaited<ReturnType<typeof getStudents>>, TError = unknown>(
 params?: GetStudentsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudents>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStudents>>,
          TError,
          Awaited<ReturnType<typeof getStudents>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStudents<TData = Awaited<ReturnType<typeof getStudents>>, TError = unknown>(
 params?: GetStudentsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudents>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Students
 */

export function useGetStudents<TData = Awaited<ReturnType<typeof getStudents>>, TError = unknown>(
 params?: GetStudentsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudents>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetStudentsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Retrieve current authenticated user profile.
 * @summary Get My Profile
 */
export type getStudentsMeResponse200 = {
  data: GetStudentsMe200
  status: 200
}

export type getStudentsMeResponse404 = {
  data: void
  status: 404
}
    
export type getStudentsMeResponseSuccess = (getStudentsMeResponse200) & {
  headers: Headers;
};
export type getStudentsMeResponseError = (getStudentsMeResponse404) & {
  headers: Headers;
};

export type getStudentsMeResponse = (getStudentsMeResponseSuccess | getStudentsMeResponseError)

export const getGetStudentsMeUrl = () => {




  return `/students/me`
}

export const getStudentsMe = async ( options?: RequestInit): Promise<getStudentsMeResponse> => {
  
  return customInstance<getStudentsMeResponse>(getGetStudentsMeUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetStudentsMeQueryKey = () => {
    return [
    `/students/me`
    ] as const;
    }

    
export const getGetStudentsMeQueryOptions = <TData = Awaited<ReturnType<typeof getStudentsMe>>, TError = void>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentsMe>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStudentsMeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStudentsMe>>> = ({ signal }) => getStudentsMe({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getStudentsMe>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetStudentsMeQueryResult = NonNullable<Awaited<ReturnType<typeof getStudentsMe>>>
export type GetStudentsMeQueryError = void


export function useGetStudentsMe<TData = Awaited<ReturnType<typeof getStudentsMe>>, TError = void>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentsMe>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStudentsMe>>,
          TError,
          Awaited<ReturnType<typeof getStudentsMe>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStudentsMe<TData = Awaited<ReturnType<typeof getStudentsMe>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentsMe>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStudentsMe>>,
          TError,
          Awaited<ReturnType<typeof getStudentsMe>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStudentsMe<TData = Awaited<ReturnType<typeof getStudentsMe>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentsMe>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get My Profile
 */

export function useGetStudentsMe<TData = Awaited<ReturnType<typeof getStudentsMe>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentsMe>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetStudentsMeQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Retrieve current authenticated student conduct score and history
 * @summary Get My Conduct Score
 */
export type getConductMeResponse200 = {
  data: GetConductMe200
  status: 200
}

export type getConductMeResponse404 = {
  data: void
  status: 404
}
    
export type getConductMeResponseSuccess = (getConductMeResponse200) & {
  headers: Headers;
};
export type getConductMeResponseError = (getConductMeResponse404) & {
  headers: Headers;
};

export type getConductMeResponse = (getConductMeResponseSuccess | getConductMeResponseError)

export const getGetConductMeUrl = (params?: GetConductMeParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {

    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/conduct/me?${stringifiedParams}` : `/conduct/me`
}

export const getConductMe = async (params?: GetConductMeParams, options?: RequestInit): Promise<getConductMeResponse> => {
  
  return customInstance<getConductMeResponse>(getGetConductMeUrl(params),
  {      
    ...options,
    method: 'GET'


  }
);}





export const getGetConductMeQueryKey = (params?: GetConductMeParams,) => {
    return [
    `/conduct/me`, ...(params ? [params] : [])
    ] as const;
    }


export const getGetConductMeQueryOptions = <TData = Awaited<ReturnType<typeof getConductMe>>, TError = void>(params?: GetConductMeParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getConductMe>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetConductMeQueryKey(params);



    const queryFn: QueryFunction<Awaited<ReturnType<typeof getConductMe>>> = ({ signal }) => getConductMe(params, { signal, ...requestOptions });

      



   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getConductMe>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetConductMeQueryResult = NonNullable<Awaited<ReturnType<typeof getConductMe>>>
export type GetConductMeQueryError = void


export function useGetConductMe<TData = Awaited<ReturnType<typeof getConductMe>>, TError = void>(
 params: undefined |  GetConductMeParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getConductMe>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getConductMe>>,
          TError,
          Awaited<ReturnType<typeof getConductMe>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetConductMe<TData = Awaited<ReturnType<typeof getConductMe>>, TError = void>(
 params?: GetConductMeParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getConductMe>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getConductMe>>,
          TError,
          Awaited<ReturnType<typeof getConductMe>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetConductMe<TData = Awaited<ReturnType<typeof getConductMe>>, TError = void>(
 params?: GetConductMeParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getConductMe>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get My Conduct Score
 */

export function useGetConductMe<TData = Awaited<ReturnType<typeof getConductMe>>, TError = void>(
 params?: GetConductMeParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getConductMe>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetConductMeQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Retrieve specific student conduct score and history (teachers/affairs only)
 * @summary Get Student Conduct Score
 */
export type getConductStudentStudentIdResponse200 = {
  data: GetConductStudentStudentId200
  status: 200
}

export type getConductStudentStudentIdResponse404 = {
  data: void
  status: 404
}
    
export type getConductStudentStudentIdResponseSuccess = (getConductStudentStudentIdResponse200) & {
  headers: Headers;
};
export type getConductStudentStudentIdResponseError = (getConductStudentStudentIdResponse404) & {
  headers: Headers;
};

export type getConductStudentStudentIdResponse = (getConductStudentStudentIdResponseSuccess | getConductStudentStudentIdResponseError)

export const getGetConductStudentStudentIdUrl = (studentId: string,
    params?: GetConductStudentStudentIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {

    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/conduct/student/${studentId}?${stringifiedParams}` : `/conduct/student/${studentId}`
}

export const getConductStudentStudentId = async (studentId: string,
    params?: GetConductStudentStudentIdParams, options?: RequestInit): Promise<getConductStudentStudentIdResponse> => {
  
  return customInstance<getConductStudentStudentIdResponse>(getGetConductStudentStudentIdUrl(studentId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetConductStudentStudentIdQueryKey = (studentId?: string,
    params?: GetConductStudentStudentIdParams,) => {
    return [
    `/conduct/student/${studentId}`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetConductStudentStudentIdQueryOptions = <TData = Awaited<ReturnType<typeof getConductStudentStudentId>>, TError = void>(studentId: string,
    params?: GetConductStudentStudentIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getConductStudentStudentId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetConductStudentStudentIdQueryKey(studentId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getConductStudentStudentId>>> = ({ signal }) => getConductStudentStudentId(studentId,params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(studentId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getConductStudentStudentId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetConductStudentStudentIdQueryResult = NonNullable<Awaited<ReturnType<typeof getConductStudentStudentId>>>
export type GetConductStudentStudentIdQueryError = void


export function useGetConductStudentStudentId<TData = Awaited<ReturnType<typeof getConductStudentStudentId>>, TError = void>(
 studentId: string,
    params: undefined |  GetConductStudentStudentIdParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getConductStudentStudentId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getConductStudentStudentId>>,
          TError,
          Awaited<ReturnType<typeof getConductStudentStudentId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetConductStudentStudentId<TData = Awaited<ReturnType<typeof getConductStudentStudentId>>, TError = void>(
 studentId: string,
    params?: GetConductStudentStudentIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getConductStudentStudentId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getConductStudentStudentId>>,
          TError,
          Awaited<ReturnType<typeof getConductStudentStudentId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetConductStudentStudentId<TData = Awaited<ReturnType<typeof getConductStudentStudentId>>, TError = void>(
 studentId: string,
    params?: GetConductStudentStudentIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getConductStudentStudentId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Student Conduct Score
 */

export function useGetConductStudentStudentId<TData = Awaited<ReturnType<typeof getConductStudentStudentId>>, TError = void>(
 studentId: string,
    params?: GetConductStudentStudentIdParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getConductStudentStudentId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetConductStudentStudentIdQueryOptions(studentId,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Record a conduct score change (teachers/affairs only)
 * @summary Create Conduct Log
 */
export type postConductLogsResponse200 = {
  data: PostConductLogs200
  status: 200
}

export type postConductLogsResponse403 = {
  data: void
  status: 403
}

export type postConductLogsResponse404 = {
  data: void
  status: 404
}
    
export type postConductLogsResponseSuccess = (postConductLogsResponse200) & {
  headers: Headers;
};
export type postConductLogsResponseError = (postConductLogsResponse403 | postConductLogsResponse404) & {
  headers: Headers;
};

export type postConductLogsResponse = (postConductLogsResponseSuccess | postConductLogsResponseError)

export const getPostConductLogsUrl = () => {




  return `/conduct/logs`
}

export const postConductLogs = async (postConductLogsBody: PostConductLogsBody, options?: RequestInit): Promise<postConductLogsResponse> => {

  return customInstance<postConductLogsResponse>(getPostConductLogsUrl(),
  {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      postConductLogsBody,)
  }
);}




export const getPostConductLogsMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postConductLogs>>, TError,{data: PostConductLogsBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postConductLogs>>, TError,{data: PostConductLogsBody}, TContext> => {

const mutationKey = ['postConductLogs'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postConductLogs>>, {data: PostConductLogsBody}> = (props) => {
          const {data} = props ?? {};

          return  postConductLogs(data,requestOptions)
        }






  return  { mutationFn, ...mutationOptions }}

    export type PostConductLogsMutationResult = NonNullable<Awaited<ReturnType<typeof postConductLogs>>>
    export type PostConductLogsMutationBody = PostConductLogsBody
    export type PostConductLogsMutationError = void

    /**
 * @summary Create Conduct Log
 */
export const usePostConductLogs = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postConductLogs>>, TError,{data: PostConductLogsBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postConductLogs>>,
        TError,
        {data: PostConductLogsBody},
        TContext
      > => {
      return useMutation(getPostConductLogsMutationOptions(options), queryClient);
    }
    /**
 * Retrieve list of all academic terms (semesters)
 * @summary Get Academic Terms
 */
export type getConductTermsResponse200 = {
  data: GetConductTerms200
  status: 200
}

export type getConductTermsResponseSuccess = (getConductTermsResponse200) & {
  headers: Headers;
};
;

export type getConductTermsResponse = (getConductTermsResponseSuccess)

export const getGetConductTermsUrl = () => {


  

  return `/conduct/terms`
}

export const getConductTerms = async ( options?: RequestInit): Promise<getConductTermsResponse> => {
  
  return customInstance<getConductTermsResponse>(getGetConductTermsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetConductTermsQueryKey = () => {
    return [
    `/conduct/terms`
    ] as const;
    }

    
export const getGetConductTermsQueryOptions = <TData = Awaited<ReturnType<typeof getConductTerms>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getConductTerms>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetConductTermsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getConductTerms>>> = ({ signal }) => getConductTerms({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getConductTerms>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetConductTermsQueryResult = NonNullable<Awaited<ReturnType<typeof getConductTerms>>>
export type GetConductTermsQueryError = unknown


export function useGetConductTerms<TData = Awaited<ReturnType<typeof getConductTerms>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getConductTerms>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getConductTerms>>,
          TError,
          Awaited<ReturnType<typeof getConductTerms>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetConductTerms<TData = Awaited<ReturnType<typeof getConductTerms>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getConductTerms>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getConductTerms>>,
          TError,
          Awaited<ReturnType<typeof getConductTerms>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetConductTerms<TData = Awaited<ReturnType<typeof getConductTerms>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getConductTerms>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Academic Terms
 */

export function useGetConductTerms<TData = Awaited<ReturnType<typeof getConductTerms>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getConductTerms>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetConductTermsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Returns all urgent/latest notifications for the dashboard widget
 * @summary Get dashboard notifications
 */
export type getNotificationsDashboardResponse200 = {
  data: GetNotificationsDashboard200
  status: 200
}

export type getNotificationsDashboardResponse500 = {
  data: GetNotificationsDashboard500
  status: 500
}
    
export type getNotificationsDashboardResponseSuccess = (getNotificationsDashboardResponse200) & {
  headers: Headers;
};
export type getNotificationsDashboardResponseError = (getNotificationsDashboardResponse500) & {
  headers: Headers;
};

export type getNotificationsDashboardResponse = (getNotificationsDashboardResponseSuccess | getNotificationsDashboardResponseError)

export const getGetNotificationsDashboardUrl = () => {


  

  return `/notifications/dashboard`
}

export const getNotificationsDashboard = async ( options?: RequestInit): Promise<getNotificationsDashboardResponse> => {
  
  return customInstance<getNotificationsDashboardResponse>(getGetNotificationsDashboardUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetNotificationsDashboardQueryKey = () => {
    return [
    `/notifications/dashboard`
    ] as const;
    }

    
export const getGetNotificationsDashboardQueryOptions = <TData = Awaited<ReturnType<typeof getNotificationsDashboard>>, TError = GetNotificationsDashboard500>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNotificationsDashboard>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetNotificationsDashboardQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getNotificationsDashboard>>> = ({ signal }) => getNotificationsDashboard({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getNotificationsDashboard>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetNotificationsDashboardQueryResult = NonNullable<Awaited<ReturnType<typeof getNotificationsDashboard>>>
export type GetNotificationsDashboardQueryError = GetNotificationsDashboard500


export function useGetNotificationsDashboard<TData = Awaited<ReturnType<typeof getNotificationsDashboard>>, TError = GetNotificationsDashboard500>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNotificationsDashboard>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNotificationsDashboard>>,
          TError,
          Awaited<ReturnType<typeof getNotificationsDashboard>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetNotificationsDashboard<TData = Awaited<ReturnType<typeof getNotificationsDashboard>>, TError = GetNotificationsDashboard500>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNotificationsDashboard>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNotificationsDashboard>>,
          TError,
          Awaited<ReturnType<typeof getNotificationsDashboard>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetNotificationsDashboard<TData = Awaited<ReturnType<typeof getNotificationsDashboard>>, TError = GetNotificationsDashboard500>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNotificationsDashboard>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get dashboard notifications
 */

export function useGetNotificationsDashboard<TData = Awaited<ReturnType<typeof getNotificationsDashboard>>, TError = GetNotificationsDashboard500>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNotificationsDashboard>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetNotificationsDashboardQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Returns paginated list of notifications
 * @summary Get all notifications
 */
export type getNotificationsResponse200 = {
  data: GetNotifications200
  status: 200
}

export type getNotificationsResponse401 = {
  data: GetNotifications401
  status: 401
}

export type getNotificationsResponse500 = {
  data: GetNotifications500
  status: 500
}
    
export type getNotificationsResponseSuccess = (getNotificationsResponse200) & {
  headers: Headers;
};
export type getNotificationsResponseError = (getNotificationsResponse401 | getNotificationsResponse500) & {
  headers: Headers;
};

export type getNotificationsResponse = (getNotificationsResponseSuccess | getNotificationsResponseError)

export const getGetNotificationsUrl = () => {




  return `/notifications`
}

export const getNotifications = async ( options?: RequestInit): Promise<getNotificationsResponse> => {
  
  return customInstance<getNotificationsResponse>(getGetNotificationsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetNotificationsQueryKey = () => {
    return [
    `/notifications`
    ] as const;
    }

    
export const getGetNotificationsQueryOptions = <TData = Awaited<ReturnType<typeof getNotifications>>, TError = GetNotifications401 | GetNotifications500>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNotifications>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetNotificationsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getNotifications>>> = ({ signal }) => getNotifications({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getNotifications>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetNotificationsQueryResult = NonNullable<Awaited<ReturnType<typeof getNotifications>>>
export type GetNotificationsQueryError = GetNotifications401 | GetNotifications500


export function useGetNotifications<TData = Awaited<ReturnType<typeof getNotifications>>, TError = GetNotifications401 | GetNotifications500>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNotifications>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNotifications>>,
          TError,
          Awaited<ReturnType<typeof getNotifications>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetNotifications<TData = Awaited<ReturnType<typeof getNotifications>>, TError = GetNotifications401 | GetNotifications500>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNotifications>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNotifications>>,
          TError,
          Awaited<ReturnType<typeof getNotifications>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetNotifications<TData = Awaited<ReturnType<typeof getNotifications>>, TError = GetNotifications401 | GetNotifications500>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNotifications>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all notifications
 */

export function useGetNotifications<TData = Awaited<ReturnType<typeof getNotifications>>, TError = GetNotifications401 | GetNotifications500>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNotifications>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetNotificationsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Create a new notification (Admin only)
 * @summary Create notification
 */
export type postNotificationsResponse201 = {
  data: PostNotifications201
  status: 201
}

export type postNotificationsResponse401 = {
  data: PostNotifications401
  status: 401
}

export type postNotificationsResponse403 = {
  data: PostNotifications403
  status: 403
}

export type postNotificationsResponse500 = {
  data: PostNotifications500
  status: 500
}
    
export type postNotificationsResponseSuccess = (postNotificationsResponse201) & {
  headers: Headers;
};
export type postNotificationsResponseError = (postNotificationsResponse401 | postNotificationsResponse403 | postNotificationsResponse500) & {
  headers: Headers;
};

export type postNotificationsResponse = (postNotificationsResponseSuccess | postNotificationsResponseError)

export const getPostNotificationsUrl = () => {


  

  return `/notifications`
}

export const postNotifications = async (postNotificationsBody: PostNotificationsBody, options?: RequestInit): Promise<postNotificationsResponse> => {
  
  return customInstance<postNotificationsResponse>(getPostNotificationsUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      postNotificationsBody,)
  }
);}




export const getPostNotificationsMutationOptions = <TError = PostNotifications401 | PostNotifications403 | PostNotifications500,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postNotifications>>, TError,{data: PostNotificationsBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postNotifications>>, TError,{data: PostNotificationsBody}, TContext> => {

const mutationKey = ['postNotifications'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postNotifications>>, {data: PostNotificationsBody}> = (props) => {
          const {data} = props ?? {};

          return  postNotifications(data,requestOptions)
        }






  return  { mutationFn, ...mutationOptions }}

    export type PostNotificationsMutationResult = NonNullable<Awaited<ReturnType<typeof postNotifications>>>
    export type PostNotificationsMutationBody = PostNotificationsBody
    export type PostNotificationsMutationError = PostNotifications401 | PostNotifications403 | PostNotifications500

    /**
 * @summary Create notification
 */
export const usePostNotifications = <TError = PostNotifications401 | PostNotifications403 | PostNotifications500,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postNotifications>>, TError,{data: PostNotificationsBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postNotifications>>,
        TError,
        {data: PostNotificationsBody},
        TContext
      > => {
      return useMutation(getPostNotificationsMutationOptions(options), queryClient);
    }
    /**
 * Update an existing notification (Admin only)
 * @summary Update notification
 */
export type putNotificationsIdResponse200 = {
  data: PutNotificationsId200
  status: 200
}

export type putNotificationsIdResponse401 = {
  data: PutNotificationsId401
  status: 401
}

export type putNotificationsIdResponse403 = {
  data: PutNotificationsId403
  status: 403
}

export type putNotificationsIdResponse404 = {
  data: PutNotificationsId404
  status: 404
}

export type putNotificationsIdResponse500 = {
  data: PutNotificationsId500
  status: 500
}
    
export type putNotificationsIdResponseSuccess = (putNotificationsIdResponse200) & {
  headers: Headers;
};
export type putNotificationsIdResponseError = (putNotificationsIdResponse401 | putNotificationsIdResponse403 | putNotificationsIdResponse404 | putNotificationsIdResponse500) & {
  headers: Headers;
};

export type putNotificationsIdResponse = (putNotificationsIdResponseSuccess | putNotificationsIdResponseError)

export const getPutNotificationsIdUrl = (id: string,) => {


  

  return `/notifications/${id}`
}

export const putNotificationsId = async (id: string,
    putNotificationsIdBody: PutNotificationsIdBody, options?: RequestInit): Promise<putNotificationsIdResponse> => {

  return customInstance<putNotificationsIdResponse>(getPutNotificationsIdUrl(id),
  {
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      putNotificationsIdBody,)
  }
);}




export const getPutNotificationsIdMutationOptions = <TError = PutNotificationsId401 | PutNotificationsId403 | PutNotificationsId404 | PutNotificationsId500,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putNotificationsId>>, TError,{id: string;data: PutNotificationsIdBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof putNotificationsId>>, TError,{id: string;data: PutNotificationsIdBody}, TContext> => {

const mutationKey = ['putNotificationsId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putNotificationsId>>, {id: string;data: PutNotificationsIdBody}> = (props) => {
          const {id,data} = props ?? {};

          return  putNotificationsId(id,data,requestOptions)
        }






  return  { mutationFn, ...mutationOptions }}

    export type PutNotificationsIdMutationResult = NonNullable<Awaited<ReturnType<typeof putNotificationsId>>>
    export type PutNotificationsIdMutationBody = PutNotificationsIdBody
    export type PutNotificationsIdMutationError = PutNotificationsId401 | PutNotificationsId403 | PutNotificationsId404 | PutNotificationsId500

    /**
 * @summary Update notification
 */
export const usePutNotificationsId = <TError = PutNotificationsId401 | PutNotificationsId403 | PutNotificationsId404 | PutNotificationsId500,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putNotificationsId>>, TError,{id: string;data: PutNotificationsIdBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putNotificationsId>>,
        TError,
        {id: string;data: PutNotificationsIdBody},
        TContext
      > => {
      return useMutation(getPutNotificationsIdMutationOptions(options), queryClient);
    }
    /**
 * Delete a notification (Admin only)
 * @summary Delete notification
 */
export type deleteNotificationsIdResponse200 = {
  data: DeleteNotificationsId200
  status: 200
}

export type deleteNotificationsIdResponse401 = {
  data: DeleteNotificationsId401
  status: 401
}

export type deleteNotificationsIdResponse403 = {
  data: DeleteNotificationsId403
  status: 403
}

export type deleteNotificationsIdResponse500 = {
  data: DeleteNotificationsId500
  status: 500
}

export type deleteNotificationsIdResponseSuccess = (deleteNotificationsIdResponse200) & {
  headers: Headers;
};
export type deleteNotificationsIdResponseError = (deleteNotificationsIdResponse401 | deleteNotificationsIdResponse403 | deleteNotificationsIdResponse500) & {
  headers: Headers;
};

export type deleteNotificationsIdResponse = (deleteNotificationsIdResponseSuccess | deleteNotificationsIdResponseError)

export const getDeleteNotificationsIdUrl = (id: string,) => {




  return `/notifications/${id}`
}

export const deleteNotificationsId = async (id: string, options?: RequestInit): Promise<deleteNotificationsIdResponse> => {

  return customInstance<deleteNotificationsIdResponse>(getDeleteNotificationsIdUrl(id),
  {
    ...options,
    method: 'DELETE'


  }
);}




export const getDeleteNotificationsIdMutationOptions = <TError = DeleteNotificationsId401 | DeleteNotificationsId403 | DeleteNotificationsId500,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteNotificationsId>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteNotificationsId>>, TError,{id: string}, TContext> => {

const mutationKey = ['deleteNotificationsId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteNotificationsId>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  deleteNotificationsId(id,requestOptions)
        }






  return  { mutationFn, ...mutationOptions }}

    export type DeleteNotificationsIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteNotificationsId>>>

    export type DeleteNotificationsIdMutationError = DeleteNotificationsId401 | DeleteNotificationsId403 | DeleteNotificationsId500

    /**
 * @summary Delete notification
 */
export const useDeleteNotificationsId = <TError = DeleteNotificationsId401 | DeleteNotificationsId403 | DeleteNotificationsId500,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteNotificationsId>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteNotificationsId>>,
        TError,
        {id: string},
        TContext
      > => {
      return useMutation(getDeleteNotificationsIdMutationOptions(options), queryClient);
    }
